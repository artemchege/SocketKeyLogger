import socket

"""
Делаем передачу файлов через сокеты по локалке.
Через global IP еще не научился, нужно настраивать машрутизатор (переадресацию пакетов на сервер сюда).
Ввиду того что сокеты работают по локалке IP адрес будет внутренний. Что бы посмотреть внутренний адрес
в cmd нужно ввести ipconfig, поле ipv-адрес. Это адрес внутри локалки.
Мы создали объект sock, который является экземпляром класса socket. 
Для этого мы вызвали метод из модуля socket с именем socket и передали ему два параметра — AF_INET и SOCK_DGRAMM. 
AF_INET означает, что используется IP-протокол четвертой версии. 
При желании можно использовать IPv6. 
Во втором параметре для наших целей мы можем указать одну из двух констант: SOCK_DGRAMM или SOCK_STREAM. 
Первая означает, что будет использоваться протокол UDP. Вторая — TCP.
"""
#создаем сокет:
#sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #можем прописать сокет явно
sock = socket.socket() #видимо по умолчанию тоже работает

#UDP обернул в функцию, работает по сути точно также как и TCP
def listen_udp():
    #UDP слушатель
    result = sock.recv(1024)
    print(result)
    print('Message:', result.decode('utf-8'))
    sock.close()


#привязываем сокет к адресу и порту
sock.bind(('', 9090))
#адрес можно оставить пустым или прописать внутренний ip адрес, но не 127.0.0.1

#указываем сколько запросов может стоять в очереди
sock.listen(1)

#запускаем бесконечный цикл, можно поставить try/except на прерывание через клаву
while True:
    # распаковываем кортеж, когда что-либо принимаем через сокет
    conn, addr = sock.accept()

    #будем писать время
    now = datatime.datatime.now()
    current_time = now.strftime("%H:%M%S")

    #в переменной conn находится  куча служебной информации об отправителе и получателе
    #в переменной addr находится инфа об внутреннем ip-адресе отправителя и его порт(?)
    #print('conn: ', conn, "addr: ", addr)

    #принимаем данные по 1 килобайту, зачем не знаю, работает даже если и меньше кб
    data = conn.recv(1024)

    #присланные данные можно посмотреть через принт, также их можно декодировать из байтов в строку (просто уберутся служебные символы)
    #также в decode можно указать кодировку, если получаются кракозябры
    print(data.decode(), current_time)

    #далее мы можем обработать data и послать обратно через метод conn, который является экземпляром класса сокета
    conn.send(data.upper())

#всегда закрываем коннект в конце
conn.close()